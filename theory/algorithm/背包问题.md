# 背包问题

背包问题是一类经典的动态规划，从背包问题可以衍生出各式各样的题型。我们这里会剖析动态规划的原理，结合一些常考的面试题，加深对动态规划的理解。

## 01背包问题

有N件物品和一个容量为V的背包。第i件物品的价值是w[i]，体积是v[i]，价值为w[i]。求解将哪些物品装入背包可使价值总和最大。

动态规划的常规思路，首先定义状态

定义`dp[i][j]`表示放入第`i`件物品，体积为`j`时刻的价值。

```
dp[i][j] 可以由两种状态得到

1. 如果放入第i件物品

dp[i][j] = dp[i-1][j-v[i]] + w[i]

2. 如果不放第i件物品

dp[i][j] = dp[i-1][j]

综合上面两种情况
dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
```
由上面递推方程，我们可以写出核心代码
```go
for i:=1; i <=N; i++ {
    for j = V; j >=v[i];j-- {
        dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
    }
}
```
由滚动数组技巧可以优化为
```go
for i:=1; i <=N; i++ {
    for j = V; j >=v[i];j-- {
        dp[j] = max(dp[j], dp[j-v[i]] + w[i])
    }
}
```

> 重要技巧，如果要求体积为V的背包刚好装满，初始化时dp[0] = 0 dp[1...N] = -inf。否则dp[1...N] = 0

## 完全背包问题

有N件物品和一个容量为V的背包。第i件物品的价值是w[i]，体积是v[i]，价值为w[i]。每件物品可以无限使用，求解将哪些物品装入背包可使价值总和最大。

按上面的推导方式，核心代码为
```go
dp[i][j]=max(dp[i−1][j],dp[i][j−w[i]]+v[i])

for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= W; j++) {
        dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]);
    }
}

```
滚动数组优化
```go
for i:=1; i <=N; i++ {
    for j = v[i]; j <= V; j-- {
        dp[j] = max(dp[j], dp[j-v[i]] + w[i])
    }
}
```
这里和01背包不同的地方，在于体积的迭代方向。
