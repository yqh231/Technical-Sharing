# 背包问题

背包问题是一类经典的动态规划，从背包问题可以衍生出各式各样的题型。我们这里会剖析动态规划的原理，结合一些常考的面试题，加深对动态规划的理解。

## 01背包问题

有N件物品和一个容量为V的背包。第i件物品的价值是w[i]，体积是v[i]，价值为w[i]。求解将哪些物品装入背包可使价值总和最大。

动态规划的常规思路，首先定义状态

定义`dp[i][j]`表示放入第`i`件物品，体积为`j`时刻的价值。

```
dp[i][j] 可以由两种状态得到

1. 如果放入第i件物品

dp[i][j] = dp[i-1][j-v[i]] + w[i]

2. 如果不放第i件物品

dp[i][j] = dp[i-1][j]

综合上面两种情况
dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
```
由上面递推方程，我们可以写出核心代码
```go
for i:=1; i <=N; i++ {
    for j = V; j >=v[i];j-- {
        dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i])
    }
}
```
由滚动数组技巧可以优化为
```go
for i:=1; i <=N; i++ {
    for j = V; j >=v[i];j-- {
        dp[j] = max(dp[j], dp[j-v[i]] + w[i])
    }
}
```

> 重要技巧，如果要求体积为V的背包刚好装满，初始化时dp[0] = 0 dp[1...N] = -inf。否则dp[1...N] = 0

## 完全背包问题

有N件物品和一个容量为V的背包。第i件物品的价值是w[i]，体积是v[i]，价值为w[i]。每件物品可以无限使用，求解将哪些物品装入背包可使价值总和最大。

按上面的推导方式，核心代码为
```go
dp[i][j]=max(dp[i−1][j],dp[i][j−w[i]]+v[i])

for (int i = 1; i <= n; i++) {
    for (int j = w[i]; j <= W; j++) {
        dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i]);
    }
}

```
滚动数组优化
```go
for i:=1; i <=N; i++ {
    for j = v[i]; j <= V; j-- {
        dp[j] = max(dp[j], dp[j-v[i]] + w[i])
    }
}
```
这里和01背包不同的地方，在于体积的迭代方向。

```
硬币

硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1

 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```
分析:
该题完全可以看成完全背包问题,直接套递归公式
```
dp[i][j] = dp[i-1][j] + dp[i][j-coins[i]]

--->

dp[j] = dp[j] + dp[j - coins[i]]
```

```go
func waysToChange(n int) int {
    nums := []int{1,5,10,25}
    dp := make([]int, n+1)
    dp[0] = 1
    /*外层循环要先硬币，防止重复。这里需要额外注意，可以理解为先尝试1个硬币的所有情况，然后再其基础上尝试其他硬币，就不会有顺序重复的问题。
    
    */
    for i := 0; i < 4; i++ {
        for j := nums[i]; j <=n; j++ {
            dp[j] += dp[j-nums[i]]
        }
    }
    return dp[n] % 1000000007
}

func max(a, b int) int {
    if a > b{
        return a
    }
    return b
}
```
练习
[硬币](https://leetcode-cn.com/problems/coin-lcci/)